# Diophantine Equation Solver (Compiler Course Version)

This program is an experimental solver for Diophantine equations of the form $a^x + b = c^y$, designed to find positive integer solutions $(x, y)$.

The C code in this repository is automatically generated by a more extensive Python-based research project. This specific version is configured to be a standalone C program, suitable for compilation in a compiler course environment without external dependencies.

For a detailed explanation of the mathematical methods and the complete project architecture, please refer to our research paper and the main GitHub repository:

- **Full Research Project:** [**github.com/parkcai/Diophantine**](https://github.com/parkcai/Diophantine)
- **Research Paper:** [**arxiv.org/abs/2510.11753**](https://arxiv.org/abs/2510.11753)

---

## ðŸ“Œ Course Version vs. Full Version

This version is functionally identical to the main research version, offering a complete user experience. The key difference lies in its handling of large numbers:

- **This Version**: Compiles without the **GMP** library. All calculations are performed using the standard `int` type. This limits the reliable range of coefficients due to the risk of integer overflow. It performs best when `a`, `b`, and `c` are relatively small (e.g., under 70).
- **Full Version**: Requires the GMP library to handle arbitrarily large integers, allowing it to solve a much broader class of equations.

Despite this limitation, **all operational modes, including Lean 4 proof generation, are fully available in this version.** Upon running the program, you can select from the following modes by entering a number:

- **`0` â€” Help Mode**: Displays an overview of all features.
- **`1` â€” Interactive Mode (recommended)**: Input `a`, `b`, and `c` manually to solve a single equation.
- **`2` â€” Silent Mode**: Input ranges for `a`, `b`, and `c` to perform batch solving.
- **`3` â€” Documentation Mode**: Prints the entire `transcendental_diophantine1.lean` formal document.

---

## ðŸ§ª Examples & Generated Proofs

The solver outputs a human-readable proof sketch followed by formal Lean 4 code.

#### Example 1: $5^x+3=2^y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 3)\ or\ (x,y)=(3, 7)$

**Algorithm Output:**

```lean
-- Trying to disprove y >= 8 with prime factor 2 of 2 ...
-- Trying prime 193...
-- Trying prime 257...
-- Succeeded.
/-
(Class II, Front Mode, with magic prime 257)   5 ^ x + 3 = 2 ^ y
For positive integers x, y satisfying 5 ^ x + 3 = 2 ^ y,
if y >= 8, 5 ^ x = 253 (mod 256).
So x = 35 (mod 64),
which implies x = 35, 99, 163, 227 (mod 256).
Therefore, 5 ^ x = 14, 224, 243, 33 (mod 257).
So 2 ^ y = 17, 227, 246, 36 (mod 257), but this is impossible.
Therefore, y < 8.
Further examination shows that (x, y) = (1, 3), (3, 7).
-/
theorem diophantine1_5_3_2 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 5 ^ x + 3 = 2 ^ y) :
  List.Mem (x, y) [(1, 3), (3, 7)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : y >= 8
  have h7 := Claim (2 ^ y % 256 = 0) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 5 ^ x % 256 = 253 := by omega
  have h9 := Claim (x % 64 = 35) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := 5 ^ x % 256 = 253, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (5 ^ x % 257) [14, 224, 243, 33]) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := x % 64 = 35, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (2 ^ y % 257) [17, 227, 246, 36]) [
    {prop := List.Mem (5 ^ x % 257) [14, 224, 243, 33], proof := h10},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
  ] "compute_mod_add"
  have h12 := Claim False [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := List.Mem (2 ^ y % 257) [17, 227, 246, 36], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : y <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 3), (3, 7)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
    {prop := y <= 7, proof := h7},
  ] "diophantine1_enumeration"
  exact h8
```

#### Example 2: $3^x+10=13^y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 1)\ or\ (x,y)=(7, 3)$

**Algorithm Output:**

```lean
-- Trying to disprove x >= 8 with prime factor 3 of 3 ...
-- Trying prime 17497...
-- Succeeded.
/-
(Class II, Back Mode, with magic prime 17497)   3 ^ x + 10 = 13 ^ y
For positive integers x, y satisfying 3 ^ x + 10 = 13 ^ y,
if x >= 8, 13 ^ y = 10 (mod 6561).
So y = 1461 (mod 2187),
which implies y = 1461, 3648, 5835, 8022 (mod 8748).
Therefore, 13 ^ y = 11616, 6486, 5881, 11011 (mod 17497).
So 3 ^ x = 11606, 6476, 5871, 11001 (mod 17497), but this is impossible.
Therefore, x < 8.
Further examination shows that (x, y) = (1, 1), (7, 3).
-/
theorem diophantine1_3_10_13 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 3 ^ x + 10 = 13 ^ y) :
  List.Mem (x, y) [(1, 1), (7, 3)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 8
  have h7 := Claim (3 ^ x % 6561 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 13 ^ y % 6561 = 10 := by omega
  have h9 := Claim (y % 2187 = 1461) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 13 ^ y % 6561 = 10, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 2187 = 1461, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001]) [
    {prop := List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011], proof := h10},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 1), (7, 3)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
    {prop := x <= 7, proof := h7},
  ] "diophantine1_enumeration"
  exact h8
```

#### Example 3: $2^x+89=91^y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 1)\ or\ (x,y)=(13, 2)$

**Algorithm Output:**

```lean
-- Trying to disprove y >= 3 with prime factor 7 of 91 ...
-- Trying prime 883...
-- Trying prime 1471...
-- Trying prime 2647...
-- Succeeded.
/-
(Class II, Front Mode, with magic prime 2647)   2 ^ x + 89 = 91 ^ y
For positive integers x, y satisfying 2 ^ x + 89 = 91 ^ y,
if y >= 3, 2 ^ x = 254 (mod 343).
So x = 76 (mod 147),
which implies x = 76, 223, 370, 517, 664, 811, 958, 1105, 1252 (mod 1323).
Therefore, 2 ^ x = 1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970 (mod 2647).
So 91 ^ y = 2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059 (mod 2647), but this is impossible.
Therefore, y < 3.
Further examination shows that (x, y) = (1, 1), (13, 2).
-/
theorem diophantine1_2_89_91 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 2 ^ x + 89 = 91 ^ y) :
  List.Mem (x, y) [(1, 1), (13, 2)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : y >= 3
  have h7 := Claim (91 ^ y % 343 = 0) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 3, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 2 ^ x % 343 = 254 := by omega
  have h9 := Claim (x % 147 = 76) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := 2 ^ x % 343 = 254, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (2 ^ x % 2647) [1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970]) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := x % 147 = 76, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (91 ^ y % 2647) [2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059]) [
    {prop := List.Mem (2 ^ x % 2647) [1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970], proof := h10},
    {prop := 2 ^ x + 89 = 91 ^ y, proof := h3},
  ] "compute_mod_add"
  have h12 := Claim False [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := List.Mem (91 ^ y % 2647) [2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : y <= 2 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 1), (13, 2)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 2 ^ x + 89 = 91 ^ y, proof := h3},
    {prop := y <= 2, proof := h7},
  ] "diophantine1_enumeration"
  exact h8
```

#### Example 4: $x,y\in\mathbb{N}^*\Rightarrow 101^x+3\neq103^y$

**Algorithm Output:**

```lean
-- Trying to disprove x >= 1 with prime factor 101 of 101 ...
-- Trying prime 401...
-- Trying prime 601...
-- Trying prime 701...
-- Succeeded.
/-
(Class II, Back Mode, with magic prime 701)   101 ^ x + 3 = 103 ^ y
For positive integers x, y satisfying 101 ^ x + 3 = 103 ^ y,
if x >= 1, 103 ^ y = 3 (mod 101).
So y = 69 (mod 100),
which implies y = 19 (mod 25).
Therefore, 103 ^ y = 583 (mod 701).
So 101 ^ x = 580 (mod 701), but this is impossible.
Therefore, x < 1.
So 101 ^ x + 3 = 103 ^ y is impossible.
-/
theorem diophantine1_101_3_103 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 101 ^ x + 3 = 103 ^ y) :
  False
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 1
  have h7 := Claim (101 ^ x % 101 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 103 ^ y % 101 = 3 := by omega
  have h9 := Claim (y % 100 = 69) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 103 ^ y % 101 = 3, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (103 ^ y % 701) [583]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 100 = 69, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (101 ^ x % 701) [580]) [
    {prop := List.Mem (103 ^ y % 701) [583], proof := h10},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (101 ^ x % 701) [580], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 0 := by omega
  have h8 := Claim False [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
    {prop := x <= 0, proof := h7},
  ] "diophantine1_enumeration"
  exact h8
```

---

## ðŸ“œ Citation

If you find this work useful for academic purposes, please consider citing our paper:

```bibtex
@article{Diophantine2025,
  title   = {An Effective Method for Solving a Class of Transcendental Diophantine Equations},
  author  = {Zeyu Cai},
  journal = {arXiv preprint arXiv:2510.11753},
  year    = {2025}
}
```
